#include "main.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/* ===== Config ===== */
#define APP_START   0x08010000UL
#define BOOT_MAGIC  0xB00710ADUL

UART_HandleTypeDef huart2;

/* magic flag in RAM */
__attribute__((section(".noinit"))) volatile uint32_t boot_magic;

/* printf -> UART */
int __io_putchar(int ch)
{
  HAL_UART_Transmit(&huart2, (uint8_t*)&ch, 1, 100);
  return ch;
}

/* CRC32 software (same as ESP32 code) */
static uint32_t crc32_update(uint32_t crc, const uint8_t *data, size_t len)
{
  crc = ~crc;
  for (size_t i=0;i<len;i++) {
    crc ^= data[i];
    for (int b=0;b<8;b++) {
      uint32_t m = -(crc & 1u);
      crc = (crc >> 1) ^ (0xEDB88320u & m);
    }
  }
  return ~crc;
}

/* ===== UART helpers ===== */
static int uart_readline(char *out, int max, uint32_t timeout_ms)
{
  int idx = 0;
  uint8_t c;
  uint32_t t0 = HAL_GetTick();
  while ((HAL_GetTick() - t0) < timeout_ms) {
    if (HAL_UART_Receive(&huart2, &c, 1, 10) == HAL_OK) {
      if (c=='\n' || c=='\r') {
        if (idx==0) continue;
        out[idx]=0;
        return 1;
      }
      if (idx < max-1) out[idx++] = (char)c;
    }
  }
  return 0;
}

static int uart_readbytes(uint8_t *buf, uint32_t len, uint32_t timeout_ms)
{
  uint32_t got = 0;
  uint32_t t0 = HAL_GetTick();
  while (got < len && (HAL_GetTick()-t0) < timeout_ms) {
    uint32_t chunk = len - got;
    if (chunk > 256) chunk = 256;
    if (HAL_UART_Receive(&huart2, buf+got, chunk, 50) == HAL_OK) got += chunk;
  }
  return (got == len);
}

/* ===== Flash sector map F407 ===== */
static uint32_t sector_from_address(uint32_t addr)
{
  if (addr < 0x08004000) return FLASH_SECTOR_0;
  if (addr < 0x08008000) return FLASH_SECTOR_1;
  if (addr < 0x0800C000) return FLASH_SECTOR_2;
  if (addr < 0x08010000) return FLASH_SECTOR_3;
  if (addr < 0x08020000) return FLASH_SECTOR_4;
  if (addr < 0x08040000) return FLASH_SECTOR_5;
  if (addr < 0x08060000) return FLASH_SECTOR_6;
  if (addr < 0x08080000) return FLASH_SECTOR_7;
  if (addr < 0x080A0000) return FLASH_SECTOR_8;
  if (addr < 0x080C0000) return FLASH_SECTOR_9;
  if (addr < 0x080E0000) return FLASH_SECTOR_10;
  return FLASH_SECTOR_11;
}

static int flash_erase_app(uint32_t size)
{
  uint32_t start = APP_START;
  uint32_t end   = APP_START + size - 1;

  uint32_t sec_start = sector_from_address(start);
  uint32_t sec_end   = sector_from_address(end);

  FLASH_EraseInitTypeDef er = {0};
  uint32_t sectorError = 0;

  er.TypeErase    = FLASH_TYPEERASE_SECTORS;
  er.VoltageRange = VOLTAGE_RANGE_3;
  er.Sector       = sec_start;
  er.NbSectors    = (sec_end - sec_start) + 1;

  HAL_FLASH_Unlock();
  if (HAL_FLASHEx_Erase(&er, &sectorError) != HAL_OK) {
    HAL_FLASH_Lock();
    return 0;
  }
  HAL_FLASH_Lock();
  return 1;
}

static int flash_write(uint32_t addr, const uint8_t *data, uint32_t len)
{
  HAL_FLASH_Unlock();

  for (uint32_t i=0; i<len; i+=4) {
    uint32_t w = 0xFFFFFFFF;
    uint32_t remain = len - i;

    if (remain >= 4) memcpy(&w, data+i, 4);
    else {
      uint8_t tmp[4] = {0xFF,0xFF,0xFF,0xFF};
      memcpy(tmp, data+i, remain);
      memcpy(&w, tmp, 4);
    }

    if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, addr+i, (uint64_t)w) != HAL_OK) {
      HAL_FLASH_Lock();
      return 0;
    }
  }

  HAL_FLASH_Lock();
  return 1;
}

/* ===== Jump to APP ===== */
static void jump_to_app(void)
{
  uint32_t sp = *(uint32_t*)APP_START;
  uint32_t rh = *(uint32_t*)(APP_START + 4);

  if ((sp & 0x2FFE0000) != 0x20000000) {
    printf("ERR: APP invalid\r\n");
    return;
  }

  __disable_irq();
  HAL_UART_DeInit(&huart2);
  HAL_DeInit();

  SCB->VTOR = APP_START;
  __set_MSP(sp);
  ((void (*)(void))rh)();
}

/* CubeMX prototypes */
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_USART2_UART_Init(void);
void Error_Handler(void);

int main(void)
{
  HAL_Init();
  SystemClock_Config();
  MX_GPIO_Init();
  MX_USART2_UART_Init();

  /* kalau tidak ada request update -> lompat ke app */
  if (boot_magic != BOOT_MAGIC) {
    jump_to_app(); // kalau app valid, tidak balik
  }
  boot_magic = 0;

  /* masuk mode update */
  printf("BL_READY\r\n");

  char line[128];
  uint32_t fw_size = 0;
  uint32_t running_crc = 0;
  uint32_t expected_crc = 0;
  uint32_t offset = 0;

  /* BEGIN <size> */
  if (!uart_readline(line, sizeof(line), 8000)) {
    printf("ERR\r\n"); while(1){}
  }
  if (sscanf(line, "BEGIN %lu", &fw_size) != 1 || fw_size == 0) {
    printf("ERR\r\n"); while(1){}
  }
  printf("OK\r\n");

  if (!flash_erase_app(fw_size)) {
    printf("ERR\r\n"); while(1){}
  }
  printf("OK\r\n");

  while (1)
  {
    if (!uart_readline(line, sizeof(line), 15000)) {
      printf("ERR\r\n"); while(1){}
    }

    if (strncmp(line, "END ", 4) == 0) {
      unsigned long tmp=0;
      if (sscanf(line, "END %lu", &tmp) != 1) { printf("ERR\r\n"); while(1){} }
      expected_crc = (uint32_t)tmp;

      if (offset != fw_size) { printf("ERR\r\n"); while(1){} }
      if (running_crc != expected_crc) { printf("ERR\r\n"); while(1){} }

      printf("OK\r\n");
      HAL_Delay(50);
      jump_to_app();
      while(1){}
    }

    uint32_t off=0, len=0;
    if (sscanf(line, "DATA %lu %lu", &off, &len) != 2) {
      printf("ERR\r\n");
      continue;
    }
    if (len == 0 || len > 1024 || off != offset || (off+len) > fw_size) {
      printf("ERR\r\n");
      continue;
    }

    uint8_t buf[1024];
    if (!uart_readbytes(buf, len, 8000)) {
      printf("ERR\r\n");
      continue;
    }

    if (!flash_write(APP_START + off, buf, len)) {
      printf("ERR\r\n");
      continue;
    }

    running_crc = crc32_update(running_crc, buf, len);
    offset += len;

    printf("OK\r\n");
  }
}

/* Clock HSI */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) Error_Handler();

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK) Error_Handler();
}

static void MX_USART2_UART_Init(void)
{
  huart2.Instance = USART2;
  huart2.Init.BaudRate = 115200;
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart2) != HAL_OK) Error_Handler();
}

static void MX_GPIO_Init(void)
{
  __HAL_RCC_GPIOA_CLK_ENABLE();
}

void Error_Handler(void)
{
  __disable_irq();
  while (1) {}
}
